#!/usr/bin/env ruby

require 'dry/cli'
require_relative '../lib/index'

# Resources
# - https://github.com/git/git/blob/master/Documentation/gitformat-index.txt
# - https://git-scm.com/docs/git-ls-files
module DIYGit
  module CLI
    module Commands
      extend Dry::CLI::Registry

      class LsFiles < Dry::CLI::Command
        desc 'git-ls-files - Show information about files in the index and the working tree'

        option :cached, type: :boolean, default: true, desc: 'Show all files cached in Gitâ€™s index, i.e. all tracked files. (This is the default if no -c/-s/-d/-o/-u/-k/-m/--resolve-undo options are specified.)'
        option :stage, type: :boolean, default: false, desc: 'Show staged contents\' mode bits, object name and stage number in the output.'
        option :abbrev, type: :integer, desc: 'Instead of showing the full 40-byte hexadecimal object lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. Non default number of digits can be specified with --abbrev=<n>.'
        option :format, type: :string, desc: 'A string that interpolates %(fieldname) from the result being shown. It also interpolates %% to %, and %xx where xx are hex digits interpolates to character with hex code xx; for example %00 interpolates to \0 (NUL), %09 to \t (TAB) and %0a to \n (LF). --format cannot be combined with -s, -o, -k, -t, --resolve-undo and --eol.'

        class Format
          PLACEHOLDERS = %i(objectmode objecttype objectname objectsize stage path)

          def initialize(pattern)
            @pattern = pattern

            # NOTE: Actual error message contains also invail fragment of a format string.
            #       Skip it for simplicity.
            if @pattern =~ /%(?!\((#{ PLACEHOLDERS.join('|') })\))/ # '%' + not '(' any placeholder ')'
              puts "fatal: bad ls-files format #{@pattern}"
              exit 1
            end

            @indices = PLACEHOLDERS.zip(PLACEHOLDERS.map { |p| @pattern.index("%(#{p})") }).select { _2 }.sort_by { _2 }
          end

          def apply_to(entry)
            line = @pattern.dup

            @indices.reverse_each do |placeholder, index|
              value = case placeholder
                      when :objectmode
                        entry.mode
                      when :objecttype
                        entry.mode.object_type_name
                      when :objectname
                        entry.object_name.hex
                      when :objectsize
                        entry.file_size
                      when :stage
                        entry.flags.stage_number
                      when :path
                        entry.pathname
                      else
                        raise "Shouldn't reach here: unknown placeholder #{placeholder}"
                      end

              line[index, "%(#{placeholder})".size] = value.to_s
            end

            line
          end
        end

        def call(**options)
          puts options
          workdir = Dir.pwd
          index = DIYGit::Index.new(workdir)
          index.parse

          if options[:format]
            if options[:stage]
              puts "fatal: --format cannot be used with -s, -o, -k, -t, --resolve-undo, --deduplicate, --eol"
              exit 1
            end

            format = Format.new(options[:format])

            # TODO: apply abbrev
            index.entries.each do |entry|
              line = format.apply_to(entry)
              puts line
            end
          elsif options[:stage]
            if options[:abbrev]
              abbrev = Integer(options[:abbrev])

              if abbrev <= 0
                # NOTE: actually git behaves differently:
                #  - 0 - means full length (20 characters), but
                #  - negative - by some reason prints only 4 characters
                abbrev = nil
              end
            end

            index.entries.each do |entry|
              object_name = options[:abbrev] ? entry.object_name.hex[0, abbrev] : entry.object_name.hex
              line = "%s %s %s\t%s" % [entry.mode.to_s(8), object_name, entry.flags.stage_number, entry.pathname]
              puts line
            end
          elsif options[:cached]
            index.entries.each do |entry|
              puts entry.pathname
            end
          end
        end
      end

      register 'ls-files', LsFiles
    end
  end
end

Dry::CLI.new(DIYGit::CLI::Commands).call

